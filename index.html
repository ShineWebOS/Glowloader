<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Glowloader</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="lib/xterm.css" />
  <script src="lib/xterm.min.js"></script>
  <script src="lib/xterm-addon-fit.min.js"></script>
  <script src="lib/zip.min.js"></script>
  <style>
    html, body {
      height: 100%;
      width: 100vw;
      margin: 0;
      padding: 0;
      background: #000 !important;
      overflow: hidden !important;
    }
    body {
      cursor: none;
    }
    #terminal, .xterm, .xterm-viewport, .xterm-screen {
      width: 100vw !important;
      height: 100vh !important;
      min-width: 100vw;
      min-height: 100vh;
      background: #000 !important;
      color: #fff !important;
      box-sizing: border-box;
      cursor: none !important;
      position: fixed;
      left: 0; top: 0; right: 0; bottom: 0;
    }
  </style>
</head>
<body>
  <div id="terminal"></div>
  <script>
    const terminal = new window.Terminal({
      cursorBlink: true,
      theme: { background: "#000", foreground: "#fff" }
    });
    window.terminal = terminal;
    const fitAddon = new window.FitAddon.FitAddon();
    terminal.loadAddon(fitAddon);
    terminal.open(document.getElementById('terminal'));
    fitAddon.fit();
    window.addEventListener('resize', () => fitAddon.fit());

    const DB_NAME = 'glowloader-db';
    const STORE_NAME = 'boot';
    const KEY = 'boot-dir';
    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = () => req.result.createObjectStore(STORE_NAME);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }
    async function saveBootDirHandle(handle) {
      const db = await openDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      tx.objectStore(STORE_NAME).put(handle, KEY);
      return tx.complete;
    }
    async function loadBootDirHandle() {
      const db = await openDB();
      return new Promise((resolve, reject) => {
        const tx = db.transaction(STORE_NAME, 'readonly');
        const req = tx.objectStore(STORE_NAME).get(KEY);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => resolve(null);
      });
    }

    async function verifyPermission(handle, mode = 'readwrite') {
      if ((await handle.queryPermission({mode})) === "granted") return true;
      if ((await handle.requestPermission({mode})) === "granted") return true;
      return false;
    }
    async function chooseDir() {
      try {
        const dirHandle = await window.showDirectoryPicker();
        if (!(await verifyPermission(dirHandle, "readwrite"))) throw new Error("Permission denied");
        await saveBootDirHandle(dirHandle);
        return dirHandle;
      } catch (e) {
        return null;
      }
    }
    async function getMainJsFile(dirHandle) {
      try {
        let bin = await dirHandle.getDirectoryHandle("bin");
        let ash = await bin.getDirectoryHandle("ash");
        let mainjs = await ash.getFileHandle("main.js");
        return mainjs;
      } catch (e) {
        return null;
      }
    }
    async function downloadAndUnzipToDir(url, dirHandle) {
      const resp = await fetch(url);
      if (!resp.ok) throw new Error("Download failed");
      const blob = await resp.blob();
      return await unzipBlobToDir(blob, dirHandle);
    }
    async function unzipBlobToDir(blob, dirHandle) {
      const reader = new zip.ZipReader(new zip.BlobReader(blob));
      const entries = await reader.getEntries();
      for (const entry of entries) {
        if (entry.directory) {
          await createDirRecursive(dirHandle, entry.filename);
        } else {
          const fileData = await entry.getData(new zip.Uint8ArrayWriter());
          const fileHandle = await getOrCreateFileHandle(dirHandle, entry.filename, true);
          const writable = await fileHandle.createWritable();
          await writable.write(fileData);
          await writable.close();
        }
      }
      await reader.close();
    }
    async function createDirRecursive(root, path) {
      const parts = path.split('/').filter(Boolean);
      let curr = root;
      for (let i = 0; i < parts.length; ++i) {
        const part = parts[i];
        if (i === parts.length - 1) break;
        try {
          curr = await curr.getDirectoryHandle(part, {create: true});
        } catch (e) {}
      }
    }
    async function getOrCreateFileHandle(root, path, create=false) {
      const parts = path.split('/').filter(Boolean);
      let curr = root;
      for (let i = 0; i < parts.length - 1; ++i) {
        curr = await curr.getDirectoryHandle(parts[i], {create});
      }
      return await curr.getFileHandle(parts[parts.length - 1], {create});
    }

    let inputBuffer = "";
    let inputResolver = null;
    function waitInputLine() {
      return new Promise(resolve => {
        inputBuffer = "";
        inputResolver = resolve;
      });
    }
    function handleKeyInput(e) {
      const {key, domEvent} = e;
      if (inputResolver) {
        if (domEvent.key === "Enter") {
          terminal.write('\r\n');
          inputResolver(inputBuffer);
          inputResolver = null;
        } else if (domEvent.key === "Backspace") {
          if (inputBuffer.length > 0) {
            terminal.write('\b \b');
            inputBuffer = inputBuffer.slice(0, -1);
          }
        } else if (
          domEvent.key.length === 1 &&
          !domEvent.ctrlKey && !domEvent.metaKey
        ) {
          terminal.write(key);
          inputBuffer += key;
        }
      }
    }
    terminal.onKey(handleKeyInput);

    async function boot() {
      let dirHandle = await loadBootDirHandle();
      if (dirHandle && dirHandle.kind === "directory") {
        if (!(await verifyPermission(dirHandle))) dirHandle = null;
      }
      if (!dirHandle) {
        terminal.writeln("Boot entry not found");
        terminal.writeln("Press any key to add an entry");
        await new Promise(resolve => {
          const handler = () => {
            window.removeEventListener('keydown', handler, true);
            resolve();
          };
          window.addEventListener('keydown', handler, true);
        });
        dirHandle = await chooseDir();
        if (!dirHandle) {
          terminal.writeln("No directory selected. Reloading...");
          setTimeout(() => location.reload(), 2000);
          return;
        }
      }
      window.bootDirHandle = dirHandle; 

      const mainJsFile = await getMainJsFile(dirHandle);
      if (mainJsFile) {
        const file = await mainJsFile.getFile();
        const code = await file.text();
        try {
          const blobUrl = URL.createObjectURL(new Blob([code], {type: "text/javascript"}));
          await import(blobUrl);
        } catch (e) {
          terminal.writeln("Error in main.js: " + e);
          terminal.writeln("Try to fix or reinstall OS.");
        }
        return;
      }
      // No OS found
      terminal.writeln("OS is not found in boot entry");
      terminal.writeln("Choose further actions:");
      terminal.writeln("1) Reboot");
      terminal.writeln("2) Install ShineOS from the web");
      terminal.writeln("3) Install local system image");
      terminal.write("Enter a number: ");
      let action = await waitInputLine();
      action = action.trim();
      if (action === "1") {
        location.reload();
      } else if (action === "2") {
        terminal.writeln("Downloading ShineOS...");
        try {
          await downloadAndUnzipToDir("https://forbirdden.rf.gd/shineos/latest_sysimage.zip", dirHandle);
          terminal.writeln("Installation complete. Rebooting...");
          setTimeout(() => location.reload(), 1000);
        } catch (e) {
          terminal.writeln("Failed to install ShineOS: " + e);
        }
      } else if (action === "3") {
        terminal.writeln("Choose a local system image (zip)...");
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".zip,application/zip";
        input.style.display = "none";
        document.body.appendChild(input);
        input.click();
        input.onchange = async (ev) => {
          const file = input.files[0];
          if (!file) {
            terminal.writeln("No file chosen. Aborting.");
            return;
          }
          terminal.writeln("Unpacking image...");
          try {
            await unzipBlobToDir(file, dirHandle);
            terminal.writeln("Installation complete. Rebooting...");
            setTimeout(() => location.reload(), 1000);
          } catch (e) {
            terminal.writeln("Failed to unpack image: " + e);
          }
        };
      } else {
        terminal.writeln("Unknown action. Rebooting...");
        setTimeout(() => location.reload(), 1000);
      }
    }

    boot();
  </script>
</body>
</html>